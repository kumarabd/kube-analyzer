"""
Vulnerability Analyzer for KubeAnalyzer

This module scans Kubernetes containers for security vulnerabilities
using tools like Trivy and provides actionable remediation steps.
"""

import json
import logging
import subprocess
from typing import Dict, List, Optional

from ..utils.k8s_client import KubernetesClient

logger = logging.getLogger(__name__)


class VulnerabilityAnalyzer:
    """Analyzes Kubernetes containers for security vulnerabilities."""

    def __init__(self, k8s_client: KubernetesClient, trivy_path: str = "trivy"):
        """
        Initialize the VulnerabilityAnalyzer.
        
        Args:
            k8s_client: Kubernetes client instance
            trivy_path: Path to trivy binary
        """
        self.k8s_client = k8s_client
        self.trivy_path = trivy_path
        
    def analyze_container(self, image: str) -> Dict:
        """
        Analyze a container image for vulnerabilities.
        
        Args:
            image: Container image name
            
        Returns:
            Dict with vulnerability results
        """
        logger.info(f"Scanning image {image} for vulnerabilities")
        
        try:
            # Run Trivy scan in JSON format
            cmd = [
                self.trivy_path, 
                "image", 
                "--format", "json",
                image
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)
            scan_results = json.loads(result.stdout)
            
            # Process the results
            return self._process_scan_results(scan_results, image)
        except subprocess.CalledProcessError as e:
            logger.error(f"Error scanning image {image}: {e}")
            return {
                "image": image,
                "error": str(e),
                "status": "error",
                "vulnerabilities": []
            }
        except json.JSONDecodeError as e:
            logger.error(f"Error parsing Trivy output for {image}: {e}")
            return {
                "image": image,
                "error": f"Failed to parse scanner output: {str(e)}",
                "status": "error",
                "vulnerabilities": []
            }
    
    def analyze_pod(self, namespace: str, pod_name: str) -> Dict:
        """
        Analyze all containers in a pod for vulnerabilities.
        
        Args:
            namespace: Kubernetes namespace
            pod_name: Pod name
            
        Returns:
            Dict with vulnerability results for all containers
        """
        pod = self.k8s_client.get_pod(namespace, pod_name)
        if not pod:
            logger.error(f"Pod {pod_name} not found in namespace {namespace}")
            return {
                "pod": pod_name,
                "namespace": namespace,
                "status": "error",
                "error": "Pod not found",
                "containers": []
            }
        
        containers = pod.get("spec", {}).get("containers", [])
        results = {
            "pod": pod_name,
            "namespace": namespace,
            "status": "completed",
            "containers": []
        }
        
        for container in containers:
            image = container.get("image")
            if image:
                container_results = self.analyze_container(image)
                results["containers"].append({
                    "name": container.get("name"),
                    "image": image,
                    **container_results
                })
        
        # Calculate overall severity
        results["severity"] = self._calculate_overall_severity(results["containers"])
        
        return results
    
    def analyze_deployment(self, namespace: str, deployment_name: str) -> Dict:
        """
        Analyze all containers in a deployment for vulnerabilities.
        
        Args:
            namespace: Kubernetes namespace
            deployment_name: Deployment name
            
        Returns:
            Dict with vulnerability results for the deployment
        """
        deployment = self.k8s_client.get_deployment(namespace, deployment_name)
        if not deployment:
            logger.error(f"Deployment {deployment_name} not found in namespace {namespace}")
            return {
                "deployment": deployment_name,
                "namespace": namespace,
                "status": "error",
                "error": "Deployment not found",
                "containers": []
            }
        
        containers = deployment.get("spec", {}).get("template", {}).get("spec", {}).get("containers", [])
        results = {
            "deployment": deployment_name,
            "namespace": namespace,
            "status": "completed",
            "containers": []
        }
        
        for container in containers:
            image = container.get("image")
            if image:
                container_results = self.analyze_container(image)
                results["containers"].append({
                    "name": container.get("name"),
                    "image": image,
                    **container_results
                })
        
        # Calculate overall severity
        results["severity"] = self._calculate_overall_severity(results["containers"])
        
        return results
    
    def analyze(self, namespaces=None) -> Dict:
        """
        Analyze vulnerabilities across specified namespaces.
        
        Args:
            namespaces: List of namespaces to analyze. If None, all namespaces will be analyzed.
            
        Returns:
            Dict with vulnerability analysis results
        """
        logger.info(f"Analyzing vulnerabilities for namespaces: {namespaces if namespaces else 'all'}")        
        
        # Analyze each namespace separately if specified, otherwise analyze all
        namespace_results = []
        all_vulnerabilities = []
        severity_counts = {"critical": 0, "high": 0, "medium": 0, "low": 0, "unknown": 0}
        
        if not namespaces:
            try:
                namespaces = self.k8s_client.list_namespaces()
            except Exception as e:
                logger.error(f"Failed to list namespaces: {str(e)}")
                namespaces = ["default"]
                logger.info("Falling back to 'default' namespace")
        
        for namespace in namespaces:
            try:
                result = self.analyze_namespace(namespace)
                namespace_results.append(result)
                
                # Aggregate vulnerabilities and counts
                for deployment in result.get("deployments", []):
                    for container in deployment.get("containers", []):
                        all_vulnerabilities.extend(container.get("vulnerabilities", []))
                        for severity, count in container.get("severity_counts", {}).items():
                            severity_counts[severity] += count
            except Exception as e:
                logger.error(f"Error analyzing namespace {namespace}: {str(e)}")
        
        # Calculate overall vulnerability statistics
        total_vulnerabilities = sum(severity_counts.values())
        overall_severity = "low"
        if severity_counts["critical"] > 0:
            overall_severity = "critical"
        elif severity_counts["high"] > 0:
            overall_severity = "high"
        elif severity_counts["medium"] > 0:
            overall_severity = "medium"
        
        # Generate summary report
        results = {
            "namespaces_analyzed": len(namespaces),
            "vulnerability_count": total_vulnerabilities,
            "severity_counts": severity_counts,
            "overall_severity": overall_severity,
            "namespace_results": namespace_results,
        }
        
        # Generate remediation steps if vulnerabilities were found
        if total_vulnerabilities > 0:
            results["remediation"] = self.generate_remediation({"vulnerabilities": all_vulnerabilities})
        
        return results
    
    def analyze_namespace(self, namespace: str) -> Dict:
        """
        Analyze all deployments in a namespace for vulnerabilities.
        
        Args:
            namespace: Kubernetes namespace
            
        Returns:
            Dict with vulnerability results for the namespace
        """
        deployments = self.k8s_client.list_deployments(namespace)
        results = {
            "namespace": namespace,
            "status": "completed",
            "deployments": []
        }
        
        for deployment in deployments:
            deployment_results = self.analyze_deployment(namespace, deployment)
            results["deployments"].append(deployment_results)
        
        # Calculate overall severity for namespace
        all_containers = []
        for deployment in results["deployments"]:
            all_containers.extend(deployment.get("containers", []))
        
        results["severity"] = self._calculate_overall_severity(all_containers)
        
        return results
    
    def _process_scan_results(self, scan_results: Dict, image: str) -> Dict:
        """Process and format Trivy scan results."""
        vulnerabilities = []
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "unknown": 0
        }
        
        # Process vulnerabilities from scan results
        for result in scan_results.get("Results", []):
            for vuln in result.get("Vulnerabilities", []):
                severity = vuln.get("Severity", "unknown").lower()
                if severity in severity_counts:
                    severity_counts[severity] += 1
                
                vulnerabilities.append({
                    "id": vuln.get("VulnerabilityID"),
                    "package": vuln.get("PkgName"),
                    "installed_version": vuln.get("InstalledVersion"),
                    "fixed_version": vuln.get("FixedVersion"),
                    "severity": severity,
                    "title": vuln.get("Title"),
                    "description": vuln.get("Description"),
                    "references": vuln.get("References", []),
                })
        
        # Determine overall severity
        overall_severity = "low"
        if severity_counts["critical"] > 0:
            overall_severity = "critical"
        elif severity_counts["high"] > 0:
            overall_severity = "high"
        elif severity_counts["medium"] > 0:
            overall_severity = "medium"
        
        return {
            "image": image,
            "vulnerability_count": sum(severity_counts.values()),
            "severity_counts": severity_counts,
            "overall_severity": overall_severity,
            "vulnerabilities": vulnerabilities,
            "scan_time": scan_results.get("CreatedAt"),
        }
    
    def _calculate_overall_severity(self, containers: List[Dict]) -> str:
        """Calculate overall severity from container results."""
        severity_levels = ["critical", "high", "medium", "low", "unknown"]
        
        # Find the highest severity level present
        for level in severity_levels:
            for container in containers:
                severity_counts = container.get("severity_counts", {})
                if severity_counts.get(level, 0) > 0:
                    return level
        
        return "unknown"
    
    def generate_remediation(self, vulnerability_results: Dict) -> List[Dict]:
        """
        Generate remediation steps for vulnerabilities.
        
        Args:
            vulnerability_results: Results from vulnerability scan
            
        Returns:
            List of remediation actions
        """
        remediations = []
        
        # Group vulnerabilities by package to consolidate recommendations
        packages = {}
        for vuln in vulnerability_results.get("vulnerabilities", []):
            package = vuln.get("package")
            fixed_version = vuln.get("fixed_version")
            severity = vuln.get("severity")
            
            if package and fixed_version:
                if package not in packages:
                    packages[package] = {
                        "package": package,
                        "fixed_version": fixed_version,
                        "vulnerabilities": [],
                        "severity": severity
                    }
                
                packages[package]["vulnerabilities"].append(vuln.get("id"))
                
                # Update to highest severity
                if severity_level(severity) > severity_level(packages[package]["severity"]):
                    packages[package]["severity"] = severity
        
        # Create remediation steps
        for package_info in packages.values():
            remediations.append({
                "action": "update_package",
                "package": package_info["package"],
                "target_version": package_info["fixed_version"],
                "severity": package_info["severity"],
                "fixes_vulnerabilities": package_info["vulnerabilities"]
            })
        
        # Sort by severity
        remediations.sort(key=lambda x: severity_level(x["severity"]), reverse=True)
        
        return remediations


def severity_level(severity: str) -> int:
    """Convert severity string to numeric level for comparison."""
    levels = {
        "critical": 4,
        "high": 3,
        "medium": 2,
        "low": 1,
        "unknown": 0
    }
    return levels.get(severity.lower(), 0)
